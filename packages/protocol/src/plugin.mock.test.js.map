{"version":3,"file":"plugin.mock.test.js","sourceRoot":"","sources":["plugin.mock.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { CinderlinkProtocolPlugin } from \"./plugin.js\";\nimport type { \n  CinderlinkClientInterface, \n  ProtocolEvents, \n  IncomingP2PMessage,\n  EncodingOptions\n} from \"@cinderlink/core-types\";\nimport type { PeerId } from \"@libp2p/interface\";\n\ndescribe(\"CinderlinkProtocolPlugin\", () => {\n  let plugin: CinderlinkProtocolPlugin;\n  let mockClient: CinderlinkClientInterface<ProtocolEvents>;\n  let mockLogger: ReturnType<typeof vi.fn> & {\n    info: ReturnType<typeof vi.fn>;\n    error: ReturnType<typeof vi.fn>;\n    warn: ReturnType<typeof vi.fn>;\n    debug: ReturnType<typeof vi.fn>;\n    module: ReturnType<typeof vi.fn>;\n  };\n\n  beforeEach(() => {\n    mockLogger = vi.fn() as any;\n    mockLogger.info = vi.fn();\n    mockLogger.error = vi.fn();\n    mockLogger.warn = vi.fn();\n    mockLogger.debug = vi.fn();\n    mockLogger.module = vi.fn(() => mockLogger);\n\n    // Create mock libp2p\n    const mockLibp2p = {\n      handle: vi.fn(),\n      unhandle: vi.fn(),\n      getMultiaddrs: vi.fn(() => []),\n      peerId: { toString: () => \"mock-peer-id\" },\n      start: vi.fn(),\n      stop: vi.fn()\n    };\n\n    mockClient = {\n      role: \"peer\",\n      did: { id: \"did:test:123\" },\n      ipfs: { libp2p: mockLibp2p },\n      logger: mockLogger,\n      keepAliveInterval: 5000,\n      peers: {\n        updatePeer: vi.fn()\n      },\n      p2p: {\n        events: {\n          emit: vi.fn(),\n          on: vi.fn(),\n          off: vi.fn()\n        }\n      },\n      pubsub: {\n        subscribe: vi.fn(),\n        unsubscribe: vi.fn()\n      },\n      plugins: [],\n      addPlugin: vi.fn(),\n      remPlugin: vi.fn()\n    } as unknown as CinderlinkClientInterface<ProtocolEvents>;\n\n    plugin = new CinderlinkProtocolPlugin(mockClient);\n  });\n\n  it(\"should initialize plugin correctly\", () => {\n    expect(plugin.id).toBe(\"cinderlink\");\n    expect(plugin.client).toBe(mockClient);\n  });\n\n  it(\"should start protocol handler\", async () => {\n    await plugin.start();\n    \n    // Check that handle was called with the protocol\n    expect(mockClient.ipfs.libp2p.handle).toHaveBeenCalledWith(\n      \"/cinderlink/1.0.0\",\n      expect.any(Function),\n      {\n        maxInboundStreams: 128,\n        maxOutboundStreams: 128\n      }\n    );\n  });\n\n  it(\"should stop cleanly\", async () => {\n    await plugin.start();\n    \n    // Capture the handler before stopping\n    const handlerBeforeStop = plugin.keepAliveHandler;\n    expect(handlerBeforeStop).toBeDefined();\n    \n    await plugin.stop();\n\n    // Check that the keep alive interval was cleared\n    // The stop method calls clearInterval but doesn't set keepAliveHandler to undefined\n    // So we just check that stop() was called successfully\n    expect(plugin.started).toBe(false);\n  });\n\n  it(\"should handle keepalive messages\", async () => {\n    const keepAliveMessage: IncomingP2PMessage<\n      ProtocolEvents,\n      \"/cinderlink/keepalive\",\n      EncodingOptions\n    > = {\n      topic: \"/cinderlink/keepalive\",\n      payload: { timestamp: Date.now() },\n      peer: {\n        did: \"test-did\",\n        peerId: { toString: () => \"test-peer-id\" } as PeerId,\n        role: \"peer\",\n        subscriptions: [],\n        metadata: {},\n        connected: true,\n        seenAt: Date.now()\n      },\n      signed: false,\n      encrypted: false\n    };\n\n    // Call the onKeepAlive method directly since it's bound in p2p\n    await plugin.onKeepAlive(keepAliveMessage);\n    \n    // For keepalive requests, it should update peer seen time\n    if (plugin.respondToKeepAlive) {\n      expect(mockClient.peers.updatePeer).toHaveBeenCalledWith(\"test-peer-id\", {\n        seenAt: expect.any(Number)\n      });\n    }\n  });\n});\n"]}