{"version":3,"file":"encoding.js","sourceRoot":"","sources":["encoding.ts"],"names":[],"mappings":"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","sourcesContent":["import { DID, VerifyJWSResult, DagJWS } from \"dids\";\n\nimport { JWE } from \"did-jwt\";\nimport * as json from \"multiformats/codecs/json\";\nimport * as multiformats from \"multiformats\";\nimport {\n  EncodedProtocolPayload,\n  DecodedProtocolPayload,\n  EncodingOptions,\n  ProtocolRequest,\n} from \"@cinderlink/core-types\";\n\nexport async function decodePayload<\n  Payload extends ProtocolRequest = ProtocolRequest,\n  Encoding extends EncodingOptions = EncodingOptions\n>(encoded: EncodedProtocolPayload<Payload, Encoding>, did?: DID): Promise<DecodedProtocolPayload<Payload, Encoding>> {\n  let payload: Payload;\n  let senderDid: string | undefined;\n\n  if (encoded.signed) {\n    if (!did) {\n      throw new Error(\"DID required to verify JWS\");\n    }\n    \n    const verification: VerifyJWSResult | false = await did\n      .verifyJWS(encoded.payload as DagJWS)\n      .catch(() => false);\n      \n    if (verification && verification.payload) {\n      payload = verification.payload as Payload;\n      senderDid = verification.didResolutionResult.didDocument?.id;\n    } else {\n      throw new Error(\"Failed to verify JWS\");\n    }\n  } else if (encoded.encrypted) {\n    if (!did) {\n      throw new Error(\"DID required to decrypt JWE\");\n    }\n    \n    const decrypted = await did.decryptJWE(encoded.payload as JWE).catch(() => undefined);\n    if (!decrypted) {\n      throw new Error(\"Failed to decrypt JWE\");\n    }\n    \n    payload = json.decode(decrypted) as Payload;\n  } else {\n    // Plain payload\n    payload = encoded.payload as Payload;\n  }\n\n  return {\n    payload,\n    signed: encoded.signed,\n    encrypted: encoded.encrypted,\n    recipients: encoded.recipients,\n    sender: senderDid,\n  } as DecodedProtocolPayload<Payload, Encoding>;\n}\n\nexport async function encodePayload<\n  Data extends Record<string, unknown> = ProtocolRequest,\n  Encoding extends EncodingOptions = EncodingOptions\n>(\n  payload: Data,\n  options: Encoding & { did?: DID } = {} as Encoding & { did?: DID }\n): Promise<EncodedProtocolPayload<Data, Encoding>> {\n  const { sign = false, encrypt = false, recipients, did } = options;\n\n  let encodedPayload: DagJWS | JWE | Data;\n  let signed = false;\n  let encrypted = false;\n\n  if (sign && encrypt) {\n    throw new Error(\"Cannot both sign and encrypt in a single operation\");\n  }\n\n  if (sign) {\n    if (!did) {\n      throw new Error(\"DID required for signing\");\n    }\n    \n    const jws = await did.createJWS(payload);\n    if (!jws) {\n      throw new Error(\"Failed to create JWS signature\");\n    }\n    \n    encodedPayload = jws;\n    signed = true;\n  } else if (encrypt) {\n    if (!recipients || recipients.length === 0) {\n      throw new Error(\"Recipients required for encryption\");\n    }\n    if (!did) {\n      throw new Error(\"DID required for encryption\");\n    }\n    \n    const jwe = await did.createJWE(json.encode(payload), recipients);\n    if (!jwe) {\n      throw new Error(\"Failed to create JWE encryption\");\n    }\n    \n    encodedPayload = jwe;\n    encrypted = true;\n  } else {\n    // Plain payload\n    encodedPayload = payload;\n  }\n\n  return {\n    payload: encodedPayload,\n    signed,\n    encrypted,\n    recipients,\n  } as EncodedProtocolPayload<Data, Encoding>;\n}\n"]}