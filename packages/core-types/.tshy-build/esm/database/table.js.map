{"version":3,"file":"table.js","sourceRoot":"","sources":["../../../src/database/table.ts"],"names":[],"mappings":"","sourcesContent":["import type { SchemaObject } from \"ajv\";\nimport type { CID } from \"multiformats\";\nimport type Emittery from \"emittery\";\nimport type { Options as SearchOptions } from \"minisearch\";\nimport type { DIDDagInterface } from \"../dag\";\nimport type Minisearch from \"minisearch\";\nimport { QueryBuilderInterface, TableQueryInterface } from \"./query\";\nimport {\n  BlockData,\n  BlockFilters,\n  BlockHeaders,\n  BlockIndexDef,\n  BlockIndex,\n  BlockAggregates,\n  BlockAggregator,\n} from \"./block\";\nimport { SubLoggerInterface } from \"../logger\";\n\nexport interface TableRow {\n  id: number;\n  uid: string;\n  createdAt?: number;\n  updatedAt?: number;\n}\n\nexport interface TableBlockInterface<\n  Row extends TableRow = TableRow,\n  Def extends TableDefinition<Row> = TableDefinition<Row>\n> {\n  table: TableInterface<Row, Def>;\n  cid: CID | undefined;\n  cache?: Partial<BlockData<Row>>;\n  changed: boolean;\n  needsRollup: boolean;\n  index?: Minisearch;\n  buildSearchIndex(): void;\n  prevCID(): Promise<string | undefined>;\n  getCID(): Promise<CID | undefined>;\n  headers(): Promise<BlockHeaders>;\n  filters(): Promise<BlockFilters<Row, Def>>;\n  records(): Promise<Record<number, Row>>;\n  search(query: string, limit: number): Promise<Row[]>;\n  save(): Promise<CID | undefined>;\n  load(force?: boolean): Promise<void>;\n  aggregate(): Promise<BlockAggregates<Row>>;\n  violatesUniqueConstraints(row: Partial<Row>): Promise<boolean>;\n  assertUniqueConstraints(row: Partial<Row>): Promise<void>;\n  addRecord(row: Row): Promise<void>;\n  updateRecord(id: number, update: Partial<Row>): Promise<Row | undefined>;\n  deleteRecord(id: number): Promise<void>;\n  toJSON(): BlockData<Row>;\n  serialize(): Promise<BlockData<Row> | undefined>;\n  toString(): string;\n}\n\nexport interface TableDefinition<Row extends TableRow = TableRow> {\n  encrypted: boolean;\n  schemaId: string;\n  schema: SchemaObject;\n  indexes: Record<string, BlockIndexDef<Row>>;\n  aggregate: Partial<Record<keyof Row, BlockAggregator>>;\n  searchOptions: SearchOptions;\n  rollup: number;\n}\n\nexport type TableEvents<\n  Row extends TableRow = TableRow,\n  Def extends TableDefinition<Row> = TableDefinition<Row>\n> = {\n  \"/table/loaded\": TableInterface<Row, Def>;\n  \"/table/saved\": TableInterface<Row, Def>;\n  \"/block/loaded\": TableBlockInterface<Row, Def>;\n  \"/block/saved\": TableBlockInterface<Row, Def>;\n  \"/record/inserted\": Row;\n  \"/record/updated\": Row;\n  \"/record/deleted\": Row;\n  \"/index/inserted\": BlockIndex;\n  \"/index/updated\": BlockIndex;\n  \"/index/deleted\": BlockIndex;\n  \"/aggregate/updated\": {\n    field: string;\n    value: BlockAggregates[keyof BlockAggregates];\n  };\n  \"/search/updated\": undefined;\n  \"/write/started\": undefined;\n  \"/write/finished\": number;\n};\n\nexport interface TableInterface<\n  Row extends TableRow = TableRow,\n  Def extends TableDefinition<Row> = TableDefinition<Row>\n> extends Emittery<TableEvents<Row, Def>> {\n  tableId: string;\n  currentIndex: number;\n  currentBlock: TableBlockInterface<Row, Def>;\n  encrypted: boolean;\n  def: Def;\n  dag: DIDDagInterface;\n  writing: boolean;\n  writeStartAt: number;\n  logger: SubLoggerInterface;\n\n  createBlock(prevCID: string | undefined): TableBlockInterface<Row, Def>;\n  setBlock(block: TableBlockInterface<Row, Def>): void;\n  insert(data: Omit<Omit<Row, \"id\">, \"uid\">): Promise<string>;\n  computeUid(data: Omit<Omit<Row, \"id\">, \"uid\">): Promise<string>;\n  bulkInsert(\n    data: Omit<Omit<Row, \"id\">, \"uid\">[]\n  ): Promise<{ saved: string[]; errors: Record<number, string> }>;\n  update(uid: string, data: Partial<Row>): Promise<Row>;\n  upsert<Index extends keyof Row = keyof Row>(\n    check: Record<Index, Row[Index]>,\n    data: Partial<Row>\n  ): Promise<Row>;\n  search(query: string, limit: number): Promise<Row[]>;\n  save(): Promise<CID | undefined>;\n  query<Params extends any[] = any[]>(\n    fn?: (\n      qb: QueryBuilderInterface<Row>,\n      ...params: Params\n    ) => QueryBuilderInterface<Row> | undefined,\n    ...params: Params\n  ): TableQueryInterface<Row, Def>;\n  load(cid: CID): Promise<void>;\n  search(query: string, limit: number): Promise<Row[]>;\n  unwind(\n    next: (event: TableUnwindEvent<Row, Def>) => Promise<void> | void\n  ): Promise<void>;\n  getById(id: number): Promise<Row | undefined>;\n  getByUid(uid: string): Promise<Row | undefined>;\n  getAllById(ids: number[]): Promise<Row[]>;\n  assertValid(data: Partial<Row>): void;\n  isValid(data: Partial<Row>): boolean;\n  lock(): void;\n  unlock(): void;\n  awaitLock(): Promise<void>;\n  awaitUnlock(): Promise<void>;\n  serialize(): Promise<BlockData<Row> | undefined>;\n  deserialize(cache: BlockData<Row, Def>): Promise<void>;\n  hasChanges(): boolean;\n}\n\nexport type TableUnwindEvent<\n  Row extends TableRow = TableRow,\n  Def extends TableDefinition<Row> = TableDefinition<Row>\n> = {\n  cid: string | undefined;\n  block: TableBlockInterface<Row, Def>;\n  resolved: boolean;\n};\n"]}