{"version":3,"file":"interface.js","sourceRoot":"","sources":["../../../src/client/interface.ts"],"names":[],"mappings":"","sourcesContent":["import type Emittery from \"emittery\";\nimport type {\n  PluginInterface,\n  PluginEventDef,\n  PluginBaseInterface,\n} from \"../plugin/types\";\nimport type {\n  IncomingP2PMessage,\n  OutgoingP2PMessage,\n  PeerRole,\n  PeerStoreInterface,\n  ReceiveEvents,\n} from \"../p2p\";\nimport type { IPFSWithLibP2P } from \"../ipfs\";\nimport type { DID } from \"dids\";\nimport type { PeerId } from \"@libp2p/interface\";\nimport type { DIDDagInterface } from \"../dag\";\nimport type { IdentityInterface } from \"../identity\";\nimport { SchemaInterface } from \"../database/schema\";\nimport { SubscribeEvents } from \"../pubsub\";\nimport { EncodingOptions, ProtocolEvents } from \"../protocol\";\nimport { CinderlinkClientEvents } from \"./types\";\nimport { FilesInterface } from \"../files/interface\";\nimport { LoggerInterface } from \"../logger\";\n\nexport interface CinderlinkClientInterface<\n  PluginEvents extends PluginEventDef = {\n    send: {};\n    receive: {};\n    publish: {};\n    subscribe: {};\n    emit: {};\n  }\n> extends Emittery<CinderlinkClientEvents[\"emit\"] & ProtocolEvents[\"emit\"]> {\n  plugins: Record<PluginInterface[\"id\"], PluginInterface>;\n  running: boolean;\n  hasServerConnection: boolean;\n  peers: PeerStoreInterface;\n  subscriptions: string[];\n  relayAddresses: string[];\n  pluginEvents: Emittery<PluginEvents[\"emit\"]>;\n  logger: LoggerInterface;\n\n  pubsub: Emittery<SubscribeEvents<PluginEvents>>;\n  p2p: Emittery<ReceiveEvents<PluginEvents & CinderlinkClientEvents>>;\n\n  ipfs: IPFSWithLibP2P;\n  files: FilesInterface;\n  did: DID;\n  address: `0x${string}`;\n  addressVerification: string;\n  peerId?: PeerId;\n  dag: DIDDagInterface;\n  schemas: Record<string, SchemaInterface>;\n  identity: IdentityInterface;\n  initialConnectTimeout: number;\n  keepAliveTimeout: number;\n  keepAliveInterval: number;\n\n  get id(): string;\n\n  addPlugin<T extends PluginBaseInterface>(plugin: T): Promise<void>;\n\n  getPlugin<T extends PluginBaseInterface>(id: string): T;\n\n  hasPlugin(id: string): boolean;\n\n  start(connectTo: string[]): Promise<void>;\n  stop(): Promise<void>;\n  save(forceRemote?: boolean, forceImmediate?: boolean): Promise<void>;\n  load(): Promise<void>;\n  connect(peerId: PeerId, role?: PeerRole): Promise<void>;\n\n  send<\n    Events extends PluginEventDef = PluginEvents,\n    Topic extends keyof Events[\"send\"] = keyof Events[\"send\"],\n    Encoding extends EncodingOptions = EncodingOptions\n  >(\n    peerId: string,\n    message: OutgoingP2PMessage<Events, Topic>,\n    encoding?: Encoding,\n    options?: { retries?: number; retryDelay?: number; offline?: boolean }\n  ): Promise<void>;\n\n  request<\n    Events extends PluginEventDef = PluginEvents,\n    OutTopic extends keyof Events[\"send\"] = keyof Events[\"send\"],\n    InTopic extends keyof Events[\"receive\"] = keyof Events[\"receive\"],\n    Encoding extends EncodingOptions = EncodingOptions\n  >(\n    peerId: string,\n    message: OutgoingP2PMessage<Events, OutTopic>,\n    options?: Encoding\n  ): Promise<IncomingP2PMessage<Events, InTopic, Encoding> | undefined>;\n\n  subscribe(topic: keyof PluginEvents[\"subscribe\"]): Promise<void>;\n\n  unsubscribe(topic: keyof PluginEvents[\"subscribe\"]): Promise<void>;\n\n  publish<\n    Events extends PluginEventDef = PluginEvents,\n    Topic extends keyof Events[\"publish\"] = keyof Events[\"publish\"]\n  >(\n    topic: Topic,\n    message: Events[\"publish\"][Topic],\n    options?: EncodingOptions\n  ): Promise<void>;\n\n  hasSchema(name: string): boolean;\n  getSchema(name: string): SchemaInterface | undefined;\n  addSchema(name: string, schema: SchemaInterface): Promise<void>;\n}\n"]}