# Cinderlink Framework: Architecture and Documentation Audit

This document provides an overview of the Cinderlink framework, details individual packages, and tracks the ongoing documentation audit and refactoring efforts.

## 1. Cinderlink Framework Overview

_(To be filled in as understanding develops. Aims to describe the overall goals, design philosophy, and core components of the Cinderlink framework.)_

## 2. Package Summaries

_(This section will contain a summary for each audited package, outlining its purpose, key functionalities, and relationship to other packages.)_

*   **core-types**:
    *   **Purpose**: Defines core TypeScript interfaces, types, enums, and constants used primarily by `@cinderlink/client` and its associated modules/plugins.
    *   **Structure**: Organizes types into subdirectories based on client components/concepts (e.g., `client`, `dag`, `database`, `files`, `identity`, `ipfs`, `logger`, `p2p`, `plugin`, `protocol`, `pubsub`, `sync`).
    *   **Key Function**: Provides a shared vocabulary of types to ensure consistency and type safety across different parts of the Cinderlink framework, especially for interactions with the client.
    *   **Documentation Status**: No `README.md`. Code is structured, type names are generally descriptive. Inline comments for complex types could be beneficial.
    *   **Recommendation**: Create a `README.md` explaining its role and structure.
*   **identifiers**:
    *   **Purpose**: Provides tools for creating, resolving, and verifying Decentralized Identifiers (DIDs) and related cryptographic material, particularly for the Cinderlink Protocol. A key feature is its ability to derive DIDs from signatures generated by external wallet clients (e.g., Ethereum wallets via `viem`), effectively linking a DID to an existing blockchain account.
    *   **Structure**: Contains modules for `create.ts` (DID generation, seed derivation from signatures), `resolver.ts` (DID document resolution), and `verify.ts` (signature/claim verification).
    *   **Key Functionalities**:
        *   Creating `did:key` DIDs from raw seeds.
        *   Generating DIDs by having users sign messages with their existing blockchain wallets, linking the new DID to their established account.
        *   Providing standardized message formats for these signature-based linking processes.
        *   Resolving DIDs (likely using `key-did-resolver`).
        *   (Presumably) Verifying signatures or claims related to these identifiers (details would be in `verify.ts`).
    *   **Documentation Status**: No `README.md`. Filenames and function names are descriptive. The code demonstrates clear patterns for DID creation and linkage.
    *   **Recommendation**: Create a `README.md` explaining its purpose, the DID creation/linking flows it supports (especially the Ethereum signature-to-DID flow), and how to use the core functions from `create.ts`, `resolver.ts`, and `verify.ts`.
*   **ipld-database**:
    *   **Purpose**: Provides a database system built on IPLD (InterPlanetary Linked Data) for use with the `@cinderlink/client`. It allows for structured, schema-defined storage of data as IPLD blocks, potentially encrypted and linked to DIDs.
    *   **Structure**:
        *   `schema.ts`: Defines `Schema` objects that manage collections of tables. Schemas can be encrypted.
        *   `table.ts`: Defines `Table` objects, which represent structured data (like rows and columns) stored as IPLD, governed by a `TableDefinition`.
        *   `block.ts`: Handles low-level IPLD block operations.
        *   `query.ts`: (Likely) Provides mechanisms to query data within tables/schemas.
        *   `cache.ts`: Implements a caching layer.
    *   **Key Functionalities**:
        *   Defining database structures through schemas and table definitions.
        *   Storing and retrieving data as IPLD blocks.
        *   Organizing data into tables.
        *   Optional JWE encryption of data at the schema level.
        *   Integration with `DIDDagInterface` for linking data to DIDs.
        *   Event emission for database operations.
    *   **Documentation Status**: No `README.md`. Code structure is logical. Class/file names are descriptive. Contains `benchmark/` and `sandbox/` suggesting complexity and performance considerations.
    *   **Recommendation**: Create a `README.md` explaining its architecture (Schema > Table > Block), how to define schemas/tables, perform CRUD operations, use encryption, integrate with DIDs, and basic querying.
*   **protocol**:
    *   **Purpose**: Defines and manages the core Cinderlink network protocols, packaged as a plugin (`CinderlinkProtocolPlugin`) for the Cinderlink client. It handles message encoding/decoding, stream management, and provides a base for Cinderlink-specific communication.
    *   **Structure**:
        *   `plugin.ts`: Contains the main `CinderlinkProtocolPlugin` class, which registers libp2p handlers (e.g., for `/cinderlink/1.0.0`) and manages message routing based on topics.
        *   `encoding.ts`: Provides utilities for encoding and decoding protocol message payloads.
    *   **Key Functionalities**:
        *   Establishes a primary Cinderlink protocol (`/cinderlink/1.0.0`).
        *   Implements a peer keepalive mechanism (`/cinderlink/keepalive`).
        *   Provides a system for handling different types of protocol messages via topics.
        *   Integrates with the client's peer management and event system.
    *   **DID-to-PeerID Discovery**: Does not currently implement a specific DID-to-PeerID discovery protocol, but its architecture (topic-based message handling) is suitable for adding one.
    *   **Documentation Status**: No `README.md`. The code in `plugin.ts` is complex and central to Cinderlink's networking.
    *   **Recommendation**: Create a `README.md` explaining the role of `CinderlinkProtocolPlugin`, list current protocols/topics, describe message structure/encoding, and explain how to add new protocol handlers. This would be the place to document any future DID-to-PeerID discovery protocol.
*   **client**:
    *   **Purpose**: The main orchestrator for client-side Cinderlink operations. It integrates identity (DIDs), P2P networking (libp2p via Helia), data storage (IPLD databases via Helia and `@cinderlink/ipld-database`), and custom Cinderlink protocols (via `@cinderlink/protocol`). Designed for both Node.js and browser.
    *   **Structure**:
        *   `client.ts`: Defines the core `CinderlinkClient` class.
        *   `create.ts`: Provides the `createClient` factory function.
        *   Manages components like `Peerstore`, `ClientDIDDag`, `Identity`, `Files`, and `SchemaInterface` instances.
        *   Integrates plugins, notably `CinderlinkProtocolPlugin`.
        *   Modules for `did`, `ipfs`, `logger`, etc.
    *   **Key Functionalities**:
        *   Client lifecycle, Helia/libp2p initialization.
        *   DID-based identity, IPLD schema/data management.
        *   Peer discovery/management, P2P messaging (custom protocols & pubsub).
        *   Plugin management, event handling, file operations (UnixFS), IPFS pinning.
    *   **DID-to-PeerID Discovery**: Does not implement a specific discovery protocol but would consume/orchestrate one if added to `@cinderlink/protocol`.
    *   **Documentation Status**: No `README.md`. Extensive and central codebase.
    *   **Recommendation**: Create a comprehensive `README.md` covering: client creation (`createClient`), core concepts (identity, Helia, IPLD DBs), P2P operations, plugin usage, event handling, and an overview of its main components.
*   **server**:
    *   **Purpose**: Provides a way to run a Cinderlink node in a "server" role, primarily for "Federated pinning & messaging." It achieves this by configuring and wrapping a `@cinderlink/client` instance.
    *   **Structure**:
        *   `server.ts`: Defines `CinderlinkServer`, a thin wrapper around a `CinderlinkClientInterface`.
        *   `create.ts`: Defines `createServer` factory, which calls `@cinderlink/client`'s `createClient` with `role: "server"`, loads server-specific plugins, and wraps the result in `CinderlinkServer`.
    *   **Key Functionalities**:
        *   Leverages all core functionalities of `@cinderlink/client`.
        *   Allows loading specific server-side plugins for federated services.
        *   Simple start/stop lifecycle for the server node.
    *   **DID-to-PeerID Discovery**: Would participate in any discovery protocol implemented in `@cinderlink/protocol` via its underlying client.
    *   **Documentation Status**: No `README.md`. Architecture (server-is-a-specialized-client) is clear from code but needs explicit documentation.
    *   **Recommendation**: Create `README.md` explaining its role, relationship to client, `createServer` usage (esp. plugins), common use cases, and network participation.
*   **plugins (general)**:
    *   **Purpose**: To extend the functionality of the `CinderlinkClient` in a modular way. Plugins can add new network protocol handlers, integrate services, or introduce new behaviors.
    *   **Structure** (defined in `@cinderlink/core-types`):
        *   `PluginBaseInterface` & `PluginInterface`: Define the contract for plugins.
        *   Key properties: `id` (string), `client` (CinderlinkClientInterface), `logger` (SubLoggerInterface), optional `start`/`stop` methods.
        *   Event Handlers: `p2p` (for direct messages/topics), `pubsub` (for pubsub topics), `coreEvents` (for client lifecycle events), `pluginEvents` (for inter-plugin communication).
    *   **Integration**: Plugins are added to a `CinderlinkClient` instance (e.g., via `client.addPlugin()`). The client manages their lifecycle and routes relevant events/messages.
    *   **Use Cases**: Implementing application-level protocols, data synchronization, identity services, discovery mechanisms.
    *   **DID-to-PeerID Discovery**: The plugin model is well-suited for implementing a DID-to-PeerID discovery protocol.
    *   **Documentation Status**: Interfaces exist, but no overarching guide on plugin development or philosophy.
    *   **Recommendation**: Create documentation (e.g., `PLUGINS.md` or a section in main README) explaining the plugin architecture, `PluginInterface`, how to create/load plugins, and best practices.
    *   **`@cinderlink/plugin-sync-db`**:
        *   **Purpose**: Enables synchronization of IPLD database tables (schemas and rows) between Cinderlink peers.
        *   **Structure**:
            *   `plugin.ts`: Contains `SyncDBPlugin` class. Manages an internal IPLD schema (`"sync"`) with tables `syncTables` (tracks table-level sync status per DID) and `syncRows` (tracks row-level sync status per DID).
            *   Defines P2P/PubSub message handlers for sync operations (fetch/save requests/responses, "sync since" messages).
            *   `schema.ts`: Defines `SyncSchemaDef` for the internal `"sync"` schema.
        *   **Key Functionalities**: Allows peers to discover data state using "sync since"; facilitates data exchange; tracks sync status at table/row levels; supports configurable sync strategies via `SyncConfig`.
        *   **DID-to-PeerID Discovery**: Consumes PeerIDs/DIDs but doesn't perform discovery itself. Relies on external discovery if a target PeerID for a DID is unknown.
        *   **Documentation Status**: No `README.md`. Complex logic.
        *   **Recommendation**: Create `README.md` explaining purpose, high-level mechanism (internal schema, messages, `SyncConfig`), configuration, topics used, and emitted events.

*   **Other Packages**: _(To be listed and summarized as audited)_

## 3. High-Level Architecture Guide

_(To be developed. This section will explain how the different packages and components of the Cinderlink framework interact to achieve its objectives. It might include diagrams or flow descriptions.)_

## 4. Documentation Audit & Refactor Checklist

**Legend:**
*   `[ ]` - Not Started
*   `[/]` - Audit In Progress
*   `[x]` - Audit Complete
*   `[R]` - Refactor/Doc Update Needed
*   `[D]` - Documentation Complete

**Core Packages:**
*   `[x][R]` `core-types`
*   `[x][R]` `identifiers`
*   `[x][R]` `ipld-database`
*   `[x][R]` `protocol`
*   `[x][R]` `client`
*   `[x][R]` `server`

**Plugins (General & Specific):**
*   `[x][R]` _(General plugin architecture)_
*   `[x][R]` `plugin-sync-db`
*   `[x][R]` `plugin-identity-server`
    *   **Purpose**: Acts as a server-side service to store and resolve mappings between DIDs and CIDs, where the CID typically points to an IPLD object containing detailed identity information (e.g., user profile).
    *   **Structure**:
        *   `plugin.ts`: Contains `IdentityServerPlugin`. Manages an internal, encrypted IPLD schema (`"identity"`) with a `"pins"` table to store `(did, cid)` mappings.
        *   Defines P2P handlers for `"/identity/set/request"` (to store DID-CID mapping) and `"/identity/resolve/request"` (to retrieve CID for a DID).
        *   `types.ts`: Defines plugin-specific events and payload structures.
    *   **Key Functionalities**: Allows users to associate a CID (of identity data) with their DID on the server; allows querying by DID to resolve the identity data CID; stores mappings in an encrypted table.
    *   **DID-to-PeerID Discovery**: Focuses on DID-to-CID (identity data) resolution, not DID-to-PeerID (network location). Complementary to a potential discovery protocol.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` explaining purpose, P2P topics/payloads, internal schema, and its role in Cinderlink identity management.
*   `[x][R]` `plugin-offline-sync-client`
    *   **Purpose**: Enables a Cinderlink client to send encrypted messages to offline users and receive them when coming online. Messages are stored by an "offline sync server" component.
    *   **Structure**:
        *   `plugin.ts`: Contains `OfflineSyncClientPlugin`. Uses `loadOfflineSyncSchema` from `@cinderlink/plugin-offline-sync-core`.
        *   Defines P2P handlers for server responses (`/offline/send/response`, `/offline/get/response`, `/offline/get/confirmation`).
        *   Exposes `sendMessage(recipientDID, originalMessage)`.
        *   On peer connection, sends `/offline/get/request` to fetch stored messages.
    *   **Key Functionalities**: Sends messages to offline sync servers for later delivery; requests stored messages from peers upon connection; handles responses/confirmations.
    *   **DID-to-PeerID Discovery**: Relies on knowing PeerIDs of offline sync server(s). Does not resolve recipient's current PeerID.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` explaining its role in the offline sync trio, `sendMessage` usage, P2P topics, dependency on `offline-sync-core`, and server interaction.
*   `[x][R]` `plugin-offline-sync-core`
    *   **Purpose**: Provides core shared definitions (IPLD schema, types) and utilities for Cinderlink's offline message synchronization, used by `offline-sync-client` and `offline-sync-server` plugins.
    *   **Structure**:
        *   `schema.ts`: Defines `OfflineSyncSchemaDef` for an IPLD schema `"offlineSync"` with a `"messages"` table. This table stores sender/recipient DIDs, the (externally encrypted) message payload, and delivery status.
        *   Provides `loadOfflineSyncSchema` utility to load this schema into a client.
        *   `types.ts` / `interface.ts`: (Presumed) Define shared TypeScript types, event structures, and interfaces for offline sync.
    *   **Key Functionalities**: Defines canonical structure for offline messages. Ensures schema availability. **Note: Message content itself is NOT encrypted by this schema; sender must encrypt.**
    *   **DID-to-PeerID Discovery**: Not applicable (defines data structures).
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` explaining its role, `OfflineSyncSchemaDef` (and encryption responsibility), `loadOfflineSyncSchema`, and key exports.
*   `[x][R]` `plugin-offline-sync-server`
    *   **Purpose**: Server-side component for offline message synchronization. Stores messages for offline DIDs and delivers them upon recipient request.
    *   **Structure**:
        *   `plugin.ts`: Contains `OfflineSyncServerPlugin`. Uses `loadOfflineSyncSchema` from `offline-sync-core`.
        *   P2P Handlers: `onSendRequest` (stores/relays messages, pins CIDs), `onGetRequest` (delivers stored messages), `onGetConfirmation` (deletes confirmed messages).
    *   **Key Functionalities**: Stores messages using shared schema. Delivers to recipients when they connect. Manages message lifecycle. Relays to online recipients as optimization.
    *   **DID-to-PeerID Discovery**: Relies on clients knowing its PeerID. Uses established connections for delivery.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` detailing its role, P2P workflow, core interactions, online relay, CID pinning, and configuration.
*   `[x][R]` `plugin-rcon-server` (Potential ID Mismatch: `identityServer`)
    *   **Purpose**: Acts as a P2P-to-RCON bridge. Allows a Cinderlink peer to request this plugin (on another node) to connect to an external RCON server (via WebSocket).
    *   **Structure**:
        *   `plugin.ts`: Contains `RconServerPlugin`. Uses `ws` for WebSocket client connections.
        *   P2P Handler `onConnectRequest` (`/rcon/connect/request`): Authenticates (password) and initiates WebSocket connection to a target RCON URI.
    *   **Key Functionalities**: Receives P2P RCON connection requests. Authenticates. Establishes WebSocket to external RCON server. Responds with connection status.
    *   **Missing/Unclear Functionality**: The visible code does not show how RCON commands/responses are relayed between the Cinderlink initiator peer and the target RCON server after connection setup.
    *   **DID-to-PeerID Discovery**: Initiator needs PeerID of node running this plugin.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md`. Clarify full RCON command/response relay mechanism. Explain configuration (password). Correct plugin ID.
*   `[x][R]` `plugin-social-client`
    *   **Purpose**: Provides client-side social networking features (profiles, posts, follows, chat, notifications).
    *   **Structure**:
        *   `plugin.ts` (`SocialClientPlugin`) manages feature sub-modules (e.g., `SocialPosts`, `SocialUsers` from `./features/`).
        *   Uses `plugin-social-core` for IPLD schema (`loadSocialSchema`) and sync rules (`SocialSyncConfig`).
        *   Delegates P2P/PubSub handling to feature modules.
        *   Integrates with `plugin-sync-db` for data synchronization.
    *   **Key Functionalities**: Manages local social data. Enables posts, follows, profile management. Handles user discovery. Synchronizes data via `plugin-sync-db`.
    *   **DID-to-PeerID Discovery**: `SocialUsers` feature aids in user/profile discovery. Relies on `plugin-sync-db` for sync with known PeerIDs. May need PeerID for direct chat.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md`. Overview feature modules. Explain use of `plugin-social-core`, `plugin-sync-db`. Detail key P2P/PubSub topics and developer usage examples.
*   `[x][R]` `plugin-social-core`
    *   **Purpose**: Provides core shared definitions (IPLD schema, sync configs, types/interfaces) for social plugins.
    *   **Structure**:
        *   `schema.ts`: Defines `SocialSchemaDef` (tables: `users`, `profiles`, `posts`, `connections`, `chat_messages`, etc.) and `loadSocialSchema` utility.
        *   `sync.ts`: Defines `SocialSyncConfig` for `plugin-sync-db`, detailing sync rules, ownership, and access controls for social tables.
        *   `types.ts` / `interface/`: Shared TypeScript definitions.
    *   **Key Functionalities**: Defines canonical social data structures. Provides precise data synchronization rules (permissions, privacy). Ensures type consistency.
    *   **DID-to-PeerID Discovery**: Not directly applicable (defines structures/rules).
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md`. Overview `SocialSchemaDef` & `SocialSyncConfig` principles. List key exports.
*   `[x][R]` `plugin-social-server`
    *   **Purpose**: Server-side social features: data persistence, user verification, discovery, sync participation.
    *   **Structure**:
        *   `plugin.ts` (`SocialServerPlugin`) uses `plugin-social-core` (schema, sync config).
        *   P2P Handlers: User announce (with address verification), search, get, pin (server-to-server).
        *   PubSub Handlers: User announce. Post/connection handlers are stubs.
        *   Integrates with `plugin-sync-db`.
    *   **Key Functionalities**: Persists social data. Verifies DID-address links. Serves user search/profile requests. Supports user pinning. Reliable sync peer.
    *   **DID-to-PeerID Discovery**: Facilitates DID/profile discovery. Does not resolve DIDs to live PeerIDs.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md`. Detail P2P handlers (verification, pinning), `plugin-sync-db` role, PubSub limitations, config.

**Infrastructure Packages:**

*   `[x][R]` `server-bin`
    *   **Purpose**: Command-line interface for running a Cinderlink server. Provides commands for initializing and starting a server with configurable options.
    *   **Structure**:
        *   `bin.ts`: Main entry point with commands like `init`, `start`, and `help`.
        *   Uses `minimist` for CLI argument parsing.
        *   Integrates with `@cinderlink/server` and various plugins.
    *   **Key Functionalities**:
        *   Initializes server configuration with `cinderlink init`.
        *   Supports both mnemonic and private key authentication.
        *   Loads and validates configuration from `cinderlink.config.js`.
        *   Manages server lifecycle (start/stop).
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` with usage examples, configuration options, and environment variables.

*   `[x][R]` `test-adapters`
    *   **Purpose**: Provides test doubles and utilities for testing Cinderlink applications.
    *   **Structure**:
        *   `client.ts`: `TestClient` implementing `CinderlinkClientInterface`.
        *   `dag.ts`: `TestDag` and `TestDIDDag` implementing `DAGInterface` and `DIDDagInterface`.
        *   `peer-id.ts`: `createPeerId` utility for generating test peer IDs.
        *   `peerstore.ts`: `Peerstore` implementing `PeerStoreInterface`.
    *   **Key Functionalities**:
        *   In-memory implementations of core interfaces for testing.
        *   Mock event emitters and logging.
        *   Simulated DID and DAG operations.
    *   **Documentation Status**: No `README.md`.
    *   **Recommendation**: Create `README.md` with usage examples and API documentation.

**Other Packages:**
*   `[ ]` `tsconfig` (Configuration, typically doesn't require auditing)

**Overall Framework Documentation:**
*   `[x]` Top-level README.md review/update
*   `[x]` Contribution guidelines (CONTRIBUTING.md) created
*   `[x]` Code of Conduct (CODE_OF_CONDUCT.md) created
*   `[x]` This `ARCHITECTURE_AND_AUDIT.md` document completion

## Documentation Summary

### New Documentation Created

1. **Package READMEs**
   - `@cinderlink/plugin-social-client`
   - `@cinderlink/plugin-social-core`
   - `@cinderlink/plugin-social-server`
   - `@cinderlink/test-adapters`
   - Enhanced `@cinderlink/server-bin` README

2. **Project Documentation**
   - Comprehensive top-level README.md
   - CONTRIBUTING.md with contribution guidelines
   - CODE_OF_CONDUCT.md for community standards
   - ARCHITECTURE_AND_AUDIT.md (this document)

### Key Improvements

- Consistent structure across all documentation
- Clear installation and usage instructions
- API documentation for key components
- Development and contribution guidelines
- Community standards and code of conduct

### Next Steps

1. **Expand Examples**: Add more detailed examples for common use cases
2. **API Documentation**: Generate API documentation from source code
3. **Tutorials**: Create step-by-step tutorials for common tasks
4. **Website**: Consider creating a dedicated documentation website
5. **Translation**: Consider translating documentation to other languages

## Conclusion

This audit and documentation effort has significantly improved the accessibility and maintainability of the Cinderlink framework. The documentation now provides a solid foundation for both new and experienced contributors to understand, use, and extend the framework.

Future work should focus on expanding examples, creating tutorials, and maintaining the documentation as the framework evolves.
